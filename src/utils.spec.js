import { describe, it } from 'mocha';
import expect from 'expect.js';
import {
  isDefined,
  isBoolean,
  isNumber,
  isString,
  isFunction,
  isPlainObject,
  isArray,
  noop,
  identity,
  call,
  partial,
  pipe,
  mapValues
} from './utils.js';

describe('utils.js', () => {
  describe('Type detection', () => {
    describe('isDefined(value)', () => {
      it('Checks if `value` is defined', () => {
        expect(isDefined(null)).to.be(true);
        expect(isDefined(0)).to.be(true);
        expect(isDefined('')).to.be(true);

        let undef;
        expect(isDefined()).to.be(false);
        expect(isDefined(undefined)).to.be(false);
        expect(isDefined(undef)).to.be(false);
      });
    });

    describe('isBoolean(value)', () => {
      it('Checks of `value` is a boolean', () => {
        expect(isBoolean(true)).to.be(true);
        expect(isBoolean(false)).to.be(true);

        expect(isBoolean(null)).to.be(false);
        expect(isBoolean('true')).to.be(false);
      });
    });

    describe('isNumber(value)', () => {
      it('Checks if `value` is a number', () => {
        expect(isNumber(1)).to.be(true);
        expect(isNumber(0)).to.be(true);
        expect(isNumber(-1)).to.be(true);
        expect(isNumber(Infinity)).to.be(true);
        expect(isNumber(NaN)).to.be(true);

        expect(isNumber('1')).to.be(false);
        expect(isNumber(null)).to.be(false);
        expect(isNumber({ valueOf: () => 3 })).to.be(false);
      });
    });

    describe('isString(value)', () => {
      it('Checks if `value` is a string', () => {
        expect(isString('abc')).to.be(true);
        expect(isString('')).to.be(true);

        expect(isString(1)).to.be(false);
        expect(isString(null)).to.be(false);
        expect(isString({ toString: () => 'abc' })).to.be(false);
      });
    });

    describe('isFunction(value)', () => {
      it('Checks if `value` is a function', () => {
        function func() {}
        expect(isFunction(() => {})).to.be(true);
        expect(isFunction(function () {})).to.be(true);
        expect(isFunction(func)).to.be(true);

        expect(isFunction(/abc/)).to.be(false);
        expect(isFunction(null)).to.be(false);
      });
    });

    describe('isPlainObject(value)', () => {
      it('Checks if `value` is a plain object', () => {
        expect(isPlainObject({ x: 0, y: 0 })).to.be(true);
        expect(isPlainObject({})).to.be(true);
        expect(isPlainObject(new Object())).to.be(true);
        expect(isPlainObject(Object.fromEntries([['a', 1]]))).to.be(true);

        expect(isPlainObject([1, 2, 3])).to.be(false);
        expect(isPlainObject(class {})).to.be(false);
        expect(isPlainObject(class extends Object {})).to.be(false);
      });
    });

    describe('isArray(value)', () => {
      it('Checks if `value` is an array', () => {
        expect(isArray([1, 2, 3])).to.be(true);
        expect(isArray([])).to.be(true);

        expect(isArray('abc')).to.be(false);
        expect(isArray({ length: 0 })).to.be(false);
      });
    });
  });

  describe('Placeholders', () => {
    describe('noop()', () => {
      it('Does nothing', () => {
        expect(noop()).to.be(undefined);
        expect(noop(3)).to.be(undefined);
      });
    });

    describe('identity(value)', () => {
      it('Returns `value`', () => {
        const ref = {};
        expect(identity(ref)).to.be(ref);
      });
    });
  });

  describe('Function helpers', () => {
    describe('call(func)', () => {
      it('Calls `func` and returns its result', () => {
        const ref = {};
        const getRef = () => ref;
        expect(call(getRef)).to.be(getRef());
      });
    });

    describe('partial(func, ...partials)', () => {
      it('Creates a function that invokes `func` with `partials` prepended to the arguments it receives', () => {
        const sum = (a, b) => a + b;
        const add2 = partial(sum, 2);
        expect(add2(1)).to.be(3);
      });
    });

    describe('pipe(...funcs)', () => {
      it('Performs left-to-right function composition', () => {
        const sum = (a, b) => a + b;
        const double = (x) => x * 2;
        const customMessage = (x) => `result: ${x}`;
        const foo = pipe(sum, double, customMessage);
        expect(foo(1, 2)).to.be('result: 6');
      });
    });
  });

  describe('Object helpers', () => {
    describe('mapValues', () => {
      it('Creates an object with the same keys as `object` and values generated by running each value of `object` through `iteratee`', () => {
        const foo = { a: 1, b: 2 };
        const double = (x) => x * 2;
        expect(mapValues(foo, double)).to.eql({ a: 2, b: 4 });
      });
    });
  });
});
